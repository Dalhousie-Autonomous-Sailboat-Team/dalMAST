<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>New_RTOS_Sailboat: SAM Serial USART (SERCOM USART) Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">New_RTOS_Sailboat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SAM Serial USART (SERCOM USART) Driver</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusart__config.html">usart_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART configuration struct.  <a href="structusart__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusart__module.html">usart_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SERCOM USART driver software device instance structure.  <a href="structusart__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad67046f395137b2a7a1ef72f83907674"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gad67046f395137b2a7a1ef72f83907674">usart_init</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, <a class="el" href="union_sercom.html">Sercom</a> *const hw, const struct <a class="el" href="structusart__config.html">usart_config</a> *const config)</td></tr>
<tr class="memdesc:gad67046f395137b2a7a1ef72f83907674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the device.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gad67046f395137b2a7a1ef72f83907674">More...</a><br /></td></tr>
<tr class="separator:gad67046f395137b2a7a1ef72f83907674"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Driver Feature Definition</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Define SERCOM USART features set according to different device family. </p>
</td></tr>
<tr class="memitem:ga4352d9150bb8cbd54d26abe3055a5ee1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga4352d9150bb8cbd54d26abe3055a5ee1">usart_dataorder</a> { <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga4352d9150bb8cbd54d26abe3055a5ee1add3a3b7f39f32c42d22991ea981e2810">USART_DATAORDER_MSB</a> = 0
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga4352d9150bb8cbd54d26abe3055a5ee1afb0c8f2d6f7da9f62dc67871d710b9af">USART_DATAORDER_LSB</a> = SERCOM_USART_CTRLA_DORD
 }</td></tr>
<tr class="memdesc:ga4352d9150bb8cbd54d26abe3055a5ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Data Order enum.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga4352d9150bb8cbd54d26abe3055a5ee1">More...</a><br /></td></tr>
<tr class="separator:ga4352d9150bb8cbd54d26abe3055a5ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff4d85053b8ea0904b5a57587b39c8f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga7ff4d85053b8ea0904b5a57587b39c8f">usart_transfer_mode</a> { <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga7ff4d85053b8ea0904b5a57587b39c8fa4756b64694eb2e2ca4f4c77c6f53786d">USART_TRANSFER_SYNCHRONOUSLY</a> = (SERCOM_USART_CTRLA_CMODE)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga7ff4d85053b8ea0904b5a57587b39c8fa5662e0cc82a73f113bb13ebb1e4c65ef">USART_TRANSFER_ASYNCHRONOUSLY</a> = (0x0ul &lt;&lt; SERCOM_USART_CTRLA_CMODE_Pos)
 }</td></tr>
<tr class="memdesc:ga7ff4d85053b8ea0904b5a57587b39c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Transfer mode enum.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga7ff4d85053b8ea0904b5a57587b39c8f">More...</a><br /></td></tr>
<tr class="separator:ga7ff4d85053b8ea0904b5a57587b39c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867cc5f0ea7d3bf651d68f0046cf6f41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga867cc5f0ea7d3bf651d68f0046cf6f41">usart_parity</a> { <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga867cc5f0ea7d3bf651d68f0046cf6f41a69c6cdd4d354d3b26c8d2f09f49d2ede">USART_PARITY_ODD</a> = SERCOM_USART_CTRLB_PMODE
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga867cc5f0ea7d3bf651d68f0046cf6f41ae5d22c99a30184aff19d77c1a970fb23">USART_PARITY_EVEN</a> = 0
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga867cc5f0ea7d3bf651d68f0046cf6f41aecf52ec650226bdc63e12a21d3b5585d">USART_PARITY_NONE</a> = 0xFF
 }</td></tr>
<tr class="memdesc:ga867cc5f0ea7d3bf651d68f0046cf6f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Parity enum.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga867cc5f0ea7d3bf651d68f0046cf6f41">More...</a><br /></td></tr>
<tr class="separator:ga867cc5f0ea7d3bf651d68f0046cf6f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bbdb9f7edb3f1866aeb498bf7c9077"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga87bbdb9f7edb3f1866aeb498bf7c9077">usart_signal_mux_settings</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077ab2330cf3ae7faacb7fd28678a77327f4">USART_RX_0_TX_0_XCK_1</a> = (SERCOM_USART_CTRLA_RXPO(0))
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077a4ad0f5cd921dd8c0787ebeba372bcc70">USART_RX_0_TX_2_XCK_3</a> = (SERCOM_USART_CTRLA_RXPO(0) | SERCOM_USART_CTRLA_TXPO)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077ac937b1e1063cc3d094c4534c022af703">USART_RX_1_TX_0_XCK_1</a> = (SERCOM_USART_CTRLA_RXPO(1))
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077a884ae3424a45469c20b4ecf9c65a8e48">USART_RX_1_TX_2_XCK_3</a> = (SERCOM_USART_CTRLA_RXPO(1) | SERCOM_USART_CTRLA_TXPO)
, <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077a730a5c0276235851c892b3a817a6d49f">USART_RX_2_TX_0_XCK_1</a> = (SERCOM_USART_CTRLA_RXPO(2))
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077aa64f03365c6e57705c9a154741523956">USART_RX_2_TX_2_XCK_3</a> = (SERCOM_USART_CTRLA_RXPO(2) | SERCOM_USART_CTRLA_TXPO)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077a01cd27a54558c7956d41d29c16cf4a40">USART_RX_3_TX_0_XCK_1</a> = (SERCOM_USART_CTRLA_RXPO(3))
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga87bbdb9f7edb3f1866aeb498bf7c9077a026e9eb10b4f94b2a0e5640a9fe22544">USART_RX_3_TX_2_XCK_3</a> = (SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO)
<br />
 }</td></tr>
<tr class="memdesc:ga87bbdb9f7edb3f1866aeb498bf7c9077"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART signal MUX settings.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga87bbdb9f7edb3f1866aeb498bf7c9077">More...</a><br /></td></tr>
<tr class="separator:ga87bbdb9f7edb3f1866aeb498bf7c9077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d8ac715e2bd7ccddc65bf2c5ceb1f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gab7d8ac715e2bd7ccddc65bf2c5ceb1f5">usart_stopbits</a> { <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a9011413422d1340bb5c343a1f3b57341">USART_STOPBITS_1</a> = 0
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a1e3cd9a88a519d93c0c300e873437a2c">USART_STOPBITS_2</a> = SERCOM_USART_CTRLB_SBMODE
 }</td></tr>
<tr class="memdesc:gab7d8ac715e2bd7ccddc65bf2c5ceb1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Stop Bits enum.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gab7d8ac715e2bd7ccddc65bf2c5ceb1f5">More...</a><br /></td></tr>
<tr class="separator:gab7d8ac715e2bd7ccddc65bf2c5ceb1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631ce7b4f60dccd392e6d6ef7d3cd4e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga631ce7b4f60dccd392e6d6ef7d3cd4e2">usart_character_size</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab1db6dc41b52d70a9185b963d9140c7f">USART_CHARACTER_SIZE_5BIT</a> = SERCOM_USART_CTRLB_CHSIZE(5)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga631ce7b4f60dccd392e6d6ef7d3cd4e2a4b631e89e72f2b939afbc4a996d358b9">USART_CHARACTER_SIZE_6BIT</a> = SERCOM_USART_CTRLB_CHSIZE(6)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab5e1a6e76a61ee79563a551ad2431726">USART_CHARACTER_SIZE_7BIT</a> = SERCOM_USART_CTRLB_CHSIZE(7)
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga631ce7b4f60dccd392e6d6ef7d3cd4e2a8679bfe526e0d92b5d313f9f5880da4b">USART_CHARACTER_SIZE_8BIT</a> = SERCOM_USART_CTRLB_CHSIZE(0)
, <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gga631ce7b4f60dccd392e6d6ef7d3cd4e2a6a7fe30ecca9dbde62c154d6619cab7f">USART_CHARACTER_SIZE_9BIT</a> = SERCOM_USART_CTRLB_CHSIZE(1)
<br />
 }</td></tr>
<tr class="memdesc:ga631ce7b4f60dccd392e6d6ef7d3cd4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Character Size.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga631ce7b4f60dccd392e6d6ef7d3cd4e2">More...</a><br /></td></tr>
<tr class="separator:ga631ce7b4f60dccd392e6d6ef7d3cd4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1b986bc581f76e99eec14ac37efe05"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a> { <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ggaab1b986bc581f76e99eec14ac37efe05a627832963965f11ae53299b802582c48">USART_TRANSCEIVER_RX</a>
, <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ggaab1b986bc581f76e99eec14ac37efe05a9d1050c223a28be7aefcbca46a0add81">USART_TRANSCEIVER_TX</a>
 }</td></tr>
<tr class="memdesc:gaab1b986bc581f76e99eec14ac37efe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">USART Transceiver.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">More...</a><br /></td></tr>
<tr class="separator:gaab1b986bc581f76e99eec14ac37efe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bc85650aed61f97fe3d5df9b430456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gae7bc85650aed61f97fe3d5df9b430456">PINMUX_DEFAULT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gae7bc85650aed61f97fe3d5df9b430456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde9ff712058ef836127e1f3368889e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaffde9ff712058ef836127e1f3368889e">PINMUX_UNUSED</a>&#160;&#160;&#160;0xFFFFFFFF</td></tr>
<tr class="separator:gaffde9ff712058ef836127e1f3368889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e37fdd22ce059c9158a818d608447a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gad3e37fdd22ce059c9158a818d608447a">USART_TIMEOUT</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="separator:gad3e37fdd22ce059c9158a818d608447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Writing and Reading</h2></td></tr>
<tr class="memitem:gaee8b142e8ad13e1e226334a9954e853c"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaee8b142e8ad13e1e226334a9954e853c">usart_write_wait</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, const uint16_t tx_data)</td></tr>
<tr class="memdesc:gaee8b142e8ad13e1e226334a9954e853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a character via the USART.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gaee8b142e8ad13e1e226334a9954e853c">More...</a><br /></td></tr>
<tr class="separator:gaee8b142e8ad13e1e226334a9954e853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7db90c51a6f17edff5f1de2a0e3d8a5"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaf7db90c51a6f17edff5f1de2a0e3d8a5">usart_read_wait</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, uint16_t *const rx_data)</td></tr>
<tr class="memdesc:gaf7db90c51a6f17edff5f1de2a0e3d8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a character via the USART.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gaf7db90c51a6f17edff5f1de2a0e3d8a5">More...</a><br /></td></tr>
<tr class="separator:gaf7db90c51a6f17edff5f1de2a0e3d8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffd0845249348d37d14c65a41132e41"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gacffd0845249348d37d14c65a41132e41">usart_write_buffer_wait</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, const uint8_t *tx_data, uint16_t length)</td></tr>
<tr class="memdesc:gacffd0845249348d37d14c65a41132e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a buffer of characters via the USART.  <a href="group__asfdoc__sam0__sercom__usart__group.html#gacffd0845249348d37d14c65a41132e41">More...</a><br /></td></tr>
<tr class="separator:gacffd0845249348d37d14c65a41132e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f788b3478e9c1fa8f0dd8d09939d3a6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga4f788b3478e9c1fa8f0dd8d09939d3a6">usart_read_buffer_wait</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, uint8_t *rx_data, uint16_t length)</td></tr>
<tr class="memdesc:ga4f788b3478e9c1fa8f0dd8d09939d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a buffer of <code>length</code> characters via the USART.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga4f788b3478e9c1fa8f0dd8d09939d3a6">More...</a><br /></td></tr>
<tr class="separator:ga4f788b3478e9c1fa8f0dd8d09939d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Callback Management</h2></td></tr>
<tr class="memitem:ga39e38593fb41abe34cec95d53c7b1e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga39e38593fb41abe34cec95d53c7b1e37">usart_register_callback</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, usart_callback_t callback_func, enum usart_callback callback_type)</td></tr>
<tr class="memdesc:ga39e38593fb41abe34cec95d53c7b1e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga39e38593fb41abe34cec95d53c7b1e37">More...</a><br /></td></tr>
<tr class="separator:ga39e38593fb41abe34cec95d53c7b1e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be8cd239bf4acd63e341be97a5cd602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga5be8cd239bf4acd63e341be97a5cd602">usart_unregister_callback</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *module, enum usart_callback callback_type)</td></tr>
<tr class="memdesc:ga5be8cd239bf4acd63e341be97a5cd602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a callback.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga5be8cd239bf4acd63e341be97a5cd602">More...</a><br /></td></tr>
<tr class="separator:ga5be8cd239bf4acd63e341be97a5cd602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Writing and Reading</h2></td></tr>
<tr class="memitem:ga3e68847c609aa708be3e1f282f760e8d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga3e68847c609aa708be3e1f282f760e8d">usart_write_job</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, const uint16_t *tx_data)</td></tr>
<tr class="memdesc:ga3e68847c609aa708be3e1f282f760e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous write a single char.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga3e68847c609aa708be3e1f282f760e8d">More...</a><br /></td></tr>
<tr class="separator:ga3e68847c609aa708be3e1f282f760e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095085e94cc009c31243df62395896fd"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga095085e94cc009c31243df62395896fd">usart_read_job</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, uint16_t *const rx_data)</td></tr>
<tr class="memdesc:ga095085e94cc009c31243df62395896fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous read a single char.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga095085e94cc009c31243df62395896fd">More...</a><br /></td></tr>
<tr class="separator:ga095085e94cc009c31243df62395896fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2811c1f5cd7fdcf653eac02812f2265c"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga2811c1f5cd7fdcf653eac02812f2265c">usart_write_buffer_job</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, uint8_t *tx_data, uint16_t length)</td></tr>
<tr class="memdesc:ga2811c1f5cd7fdcf653eac02812f2265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous buffer write.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga2811c1f5cd7fdcf653eac02812f2265c">More...</a><br /></td></tr>
<tr class="separator:ga2811c1f5cd7fdcf653eac02812f2265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b1e55af02e69454ecff04c3d712527"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga95b1e55af02e69454ecff04c3d712527">usart_read_buffer_job</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, uint8_t *rx_data, uint16_t length)</td></tr>
<tr class="memdesc:ga95b1e55af02e69454ecff04c3d712527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous buffer read.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga95b1e55af02e69454ecff04c3d712527">More...</a><br /></td></tr>
<tr class="separator:ga95b1e55af02e69454ecff04c3d712527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e77aeb7ff01d060c5c936a63581a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga08e77aeb7ff01d060c5c936a63581a99">usart_abort_job</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a> transceiver_type)</td></tr>
<tr class="memdesc:ga08e77aeb7ff01d060c5c936a63581a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels ongoing read/write operation.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga08e77aeb7ff01d060c5c936a63581a99">More...</a><br /></td></tr>
<tr class="separator:ga08e77aeb7ff01d060c5c936a63581a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80364bc53d6d6405a2a7f3b1aa507503"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga80364bc53d6d6405a2a7f3b1aa507503">usart_get_job_status</a> (struct <a class="el" href="structusart__module.html">usart_module</a> *const module, enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a> transceiver_type)</td></tr>
<tr class="memdesc:ga80364bc53d6d6405a2a7f3b1aa507503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status from the ongoing or last asynchronous transfer operation.  <a href="group__asfdoc__sam0__sercom__usart__group.html#ga80364bc53d6d6405a2a7f3b1aa507503">More...</a><br /></td></tr>
<tr class="separator:ga80364bc53d6d6405a2a7f3b1aa507503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for the configuration and management of the SERCOM module in its USART mode to transfer or receive USART data frames. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs </li>
</ul>
<p >The following peripheral is used by this module:</p><ul>
<li>SERCOM (Serial Communication Interface)</li>
</ul>
<p >The following devices can use this module:</p><ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D09/D10/D11</li>
<li>Atmel | SMART SAM D10/D11</li>
<li>Atmel | SMART SAM L21/L22</li>
<li>Atmel | SMART SAM DA1</li>
<li>Atmel | SMART SAM C20/C21</li>
<li>Atmel | SMART SAM HA1</li>
<li>Atmel | SMART SAM R30</li>
<li>Atmel | SMART SAM R34</li>
<li>Atmel | SMART SAM R35</li>
</ul>
<p >The outline of this documentation is as follows:</p><ul>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_api_overview">API Overview</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_prerequisites"></a>
Prerequisites</h1>
<p >To use the USART you need to have a GCLK generator enabled and running that can be used as the SERCOM clock source. This can either be configured in <a class="el" href="conf__clocks_8h.html" title="SAM D20 Clock configuration.">conf_clocks.h</a> or by using the system clock driver.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_overview"></a>
Module Overview</h1>
<p >This driver will use one (or more) SERCOM interface(s) in the system and configure it to run as a USART interface in either synchronous or asynchronous mode.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_features"></a>
Driver Feature Macro Definition</h2>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_USART_SYNC_SCHEME_V2 </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_OVER_SAMPLE </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_HARDWARE_FLOW_CONTROL </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_IRDA </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_LIN_SLAVE </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_COLLISION_DECTION </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_START_FRAME_DECTION </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION </td><td>SAM D21/R21/D09/D10/D11/L21/L22/DA1/C20/C21/R30/R34/R35  </td></tr>
<tr>
<td>FEATURE_USART_RS485 </td><td>SAM C20/C21  </td></tr>
<tr>
<td>FEATURE_USART_LIN_MASTER </td><td>SAM L22/C20/C21  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_frame_format"></a>
Frame Format</h2>
<p >Communication is based on frames, where the frame format can be customized to accommodate a wide range of standards. A frame consists of a start bit, a number of data bits, an optional parity bit for error detection as well as a configurable length stop bit(s) - see <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_frame_diagram">the figure below</a>. <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#asfdoc_sam0_sercom_usart_frame_params">The table below</a> shows the available parameters you can change in a frame.</p>
<p ><a class="anchor" id="asfdoc_sam0_sercom_usart_frame_params"></a></p><table class="doxtable">
<caption>USART Frame Parameters</caption>
<tr>
<th>Parameter </th><th>Options  </th></tr>
<tr>
<td>Start bit </td><td>1  </td></tr>
<tr>
<td>Data bits </td><td>5, 6, 7, 8, 9  </td></tr>
<tr>
<td>Parity bit </td><td>None, Even, Odd  </td></tr>
<tr>
<td>Stop bits </td><td>1, 2  </td></tr>
</table>
<p ><a class="anchor" id="asfdoc_sam0_sercom_usart_frame_diagram"></a></p><div class="image">
<object type="image/svg+xml" data="usart_frame.svg" width="100%" style="pointer-events: none;"></object>
<div class="caption">
USART Frame Overview</div></div>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_sync"></a>
Synchronous Mode</h2>
<p >In synchronous mode a dedicated clock line is provided; either by the USART itself if in master mode, or by an external master if in slave mode. Maximum transmission speed is the same as the GCLK clocking the USART peripheral when in slave mode, and the GCLK divided by two if in master mode. In synchronous mode the interface needs three lines to communicate:</p><ul>
<li>TX (Transmit pin)</li>
<li>RX (Receive pin)</li>
<li>XCK (Clock pin)</li>
</ul>
<h3><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_sync_sampling"></a>
Data Sampling</h3>
<p >In synchronous mode the data is sampled on either the rising or falling edge of the clock signal. This is configured by setting the clock polarity in the configuration struct.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_async"></a>
Asynchronous Mode</h2>
<p >In asynchronous mode no dedicated clock line is used, and the communication is based on matching the clock speed on the transmitter and receiver. The clock is generated from the internal SERCOM baudrate generator, and the frames are synchronized by using the frame start bits. Maximum transmission speed is limited to the SERCOM GCLK divided by 16. In asynchronous mode the interface only needs two lines to communicate:</p><ul>
<li>TX (Transmit pin)</li>
<li>RX (Receive pin)</li>
</ul>
<h3><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_async_clock_matching"></a>
Transmitter/receiver Clock Matching</h3>
<p >For successful transmit and receive using the asynchronous mode the receiver and transmitter clocks needs to be closely matched. When receiving a frame that does not match the selected baudrate closely enough the receiver will be unable to synchronize the frame(s), and garbage transmissions will result.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_parity"></a>
Parity</h2>
<p >Parity can be enabled to detect if a transmission was in error. This is done by counting the number of "1" bits in the frame. When using even parity the parity bit will be set if the total number of "1"s in the frame are an even number. If using odd parity the parity bit will be set if the total number of "1"s are odd.</p>
<p >When receiving a character the receiver will count the number of "1"s in the frame and give an error if the received frame and parity bit disagree.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_usart_overview_pin_configuration"></a>
GPIO Configuration</h2>
<p >The SERCOM module has four internal pads; the RX pin can be placed freely on any one of the four pads, and the TX and XCK pins have two predefined positions that can be selected as a pair. The pads can then be routed to an external GPIO pin using the normal pin multiplexing scheme on the SAM.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_special_considerations"></a>
Special Considerations</h1>
<p >No special considerations. </p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_extra_info"></a>
Extra Information</h1>
<p >For extra information, see <a class="el" href="asfdoc_sam0_sercom_usart_extra.html">Extra Information for SERCOM USART Driver</a>. This includes:</p><ul>
<li><a class="el" href="asfdoc_sam0_sercom_usart_extra.html#asfdoc_sam0_sercom_usart_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_usart_extra.html#asfdoc_sam0_sercom_usart_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_usart_extra.html#asfdoc_sam0_sercom_usart_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_usart_extra.html#asfdoc_sam0_sercom_usart_extra_history">Module History</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_examples"></a>
Examples</h1>
<p >For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_sercom_usart_exqsg.html">Examples for SERCOM USART Driver</a>.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_usart_api_overview"></a>
API Overview</h1>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae7bc85650aed61f97fe3d5df9b430456" name="gae7bc85650aed61f97fe3d5df9b430456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bc85650aed61f97fe3d5df9b430456">&#9670;&#160;</a></span>PINMUX_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PINMUX_DEFAULT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Default pinmux </p>

</div>
</div>
<a id="gaffde9ff712058ef836127e1f3368889e" name="gaffde9ff712058ef836127e1f3368889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde9ff712058ef836127e1f3368889e">&#9670;&#160;</a></span>PINMUX_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PINMUX_UNUSED&#160;&#160;&#160;0xFFFFFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unused pinmux </p>

</div>
</div>
<a id="gad3e37fdd22ce059c9158a818d608447a" name="gad3e37fdd22ce059c9158a818d608447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e37fdd22ce059c9158a818d608447a">&#9670;&#160;</a></span>USART_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USART_TIMEOUT&#160;&#160;&#160;0xFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >USART timeout value </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga631ce7b4f60dccd392e6d6ef7d3cd4e2" name="ga631ce7b4f60dccd392e6d6ef7d3cd4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631ce7b4f60dccd392e6d6ef7d3cd4e2">&#9670;&#160;</a></span>usart_character_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga631ce7b4f60dccd392e6d6ef7d3cd4e2">usart_character_size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Character Size. </p>
<p >Number of bits for the character sent in a frame. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab1db6dc41b52d70a9185b963d9140c7f" name="gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab1db6dc41b52d70a9185b963d9140c7f"></a>USART_CHARACTER_SIZE_5BIT&#160;</td><td class="fielddoc"><p >The char being sent in a frame is five bits long </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a4b631e89e72f2b939afbc4a996d358b9" name="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a4b631e89e72f2b939afbc4a996d358b9"></a>USART_CHARACTER_SIZE_6BIT&#160;</td><td class="fielddoc"><p >The char being sent in a frame is six bits long </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab5e1a6e76a61ee79563a551ad2431726" name="gga631ce7b4f60dccd392e6d6ef7d3cd4e2ab5e1a6e76a61ee79563a551ad2431726"></a>USART_CHARACTER_SIZE_7BIT&#160;</td><td class="fielddoc"><p >The char being sent in a frame is seven bits long </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a8679bfe526e0d92b5d313f9f5880da4b" name="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a8679bfe526e0d92b5d313f9f5880da4b"></a>USART_CHARACTER_SIZE_8BIT&#160;</td><td class="fielddoc"><p >The char being sent in a frame is eight bits long </p>
</td></tr>
<tr><td class="fieldname"><a id="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a6a7fe30ecca9dbde62c154d6619cab7f" name="gga631ce7b4f60dccd392e6d6ef7d3cd4e2a6a7fe30ecca9dbde62c154d6619cab7f"></a>USART_CHARACTER_SIZE_9BIT&#160;</td><td class="fielddoc"><p >The char being sent in a frame is nine bits long </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4352d9150bb8cbd54d26abe3055a5ee1" name="ga4352d9150bb8cbd54d26abe3055a5ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4352d9150bb8cbd54d26abe3055a5ee1">&#9670;&#160;</a></span>usart_dataorder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga4352d9150bb8cbd54d26abe3055a5ee1">usart_dataorder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Data Order enum. </p>
<p >The data order decides which MSB or LSB is shifted out first when data is transferred. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4352d9150bb8cbd54d26abe3055a5ee1add3a3b7f39f32c42d22991ea981e2810" name="gga4352d9150bb8cbd54d26abe3055a5ee1add3a3b7f39f32c42d22991ea981e2810"></a>USART_DATAORDER_MSB&#160;</td><td class="fielddoc"><p >The MSB will be shifted out first during transmission, and shifted in first during reception </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4352d9150bb8cbd54d26abe3055a5ee1afb0c8f2d6f7da9f62dc67871d710b9af" name="gga4352d9150bb8cbd54d26abe3055a5ee1afb0c8f2d6f7da9f62dc67871d710b9af"></a>USART_DATAORDER_LSB&#160;</td><td class="fielddoc"><p >The LSB will be shifted out first during transmission, and shifted in first during reception </p>
</td></tr>
</table>

</div>
</div>
<a id="ga867cc5f0ea7d3bf651d68f0046cf6f41" name="ga867cc5f0ea7d3bf651d68f0046cf6f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867cc5f0ea7d3bf651d68f0046cf6f41">&#9670;&#160;</a></span>usart_parity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga867cc5f0ea7d3bf651d68f0046cf6f41">usart_parity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Parity enum. </p>
<p >Select parity USART parity mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga867cc5f0ea7d3bf651d68f0046cf6f41a69c6cdd4d354d3b26c8d2f09f49d2ede" name="gga867cc5f0ea7d3bf651d68f0046cf6f41a69c6cdd4d354d3b26c8d2f09f49d2ede"></a>USART_PARITY_ODD&#160;</td><td class="fielddoc"><p >For odd parity checking, the parity bit will be set if number of ones being transferred is even </p>
</td></tr>
<tr><td class="fieldname"><a id="gga867cc5f0ea7d3bf651d68f0046cf6f41ae5d22c99a30184aff19d77c1a970fb23" name="gga867cc5f0ea7d3bf651d68f0046cf6f41ae5d22c99a30184aff19d77c1a970fb23"></a>USART_PARITY_EVEN&#160;</td><td class="fielddoc"><p >For even parity checking, the parity bit will be set if number of ones being received is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="gga867cc5f0ea7d3bf651d68f0046cf6f41aecf52ec650226bdc63e12a21d3b5585d" name="gga867cc5f0ea7d3bf651d68f0046cf6f41aecf52ec650226bdc63e12a21d3b5585d"></a>USART_PARITY_NONE&#160;</td><td class="fielddoc"><p >No parity checking will be executed, and there will be no parity bit in the received frame </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87bbdb9f7edb3f1866aeb498bf7c9077" name="ga87bbdb9f7edb3f1866aeb498bf7c9077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87bbdb9f7edb3f1866aeb498bf7c9077">&#9670;&#160;</a></span>usart_signal_mux_settings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga87bbdb9f7edb3f1866aeb498bf7c9077">usart_signal_mux_settings</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART signal MUX settings. </p>
<p >Set the functionality of the SERCOM pins.</p>
<p >See <a class="el" href="asfdoc_sam0_sercom_usart_mux_settings.html">SERCOM USART MUX Settings</a> for a description of the various MUX setting options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077ab2330cf3ae7faacb7fd28678a77327f4" name="gga87bbdb9f7edb3f1866aeb498bf7c9077ab2330cf3ae7faacb7fd28678a77327f4"></a>USART_RX_0_TX_0_XCK_1&#160;</td><td class="fielddoc"><p >MUX setting RX_0_TX_0_XCK_1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077a4ad0f5cd921dd8c0787ebeba372bcc70" name="gga87bbdb9f7edb3f1866aeb498bf7c9077a4ad0f5cd921dd8c0787ebeba372bcc70"></a>USART_RX_0_TX_2_XCK_3&#160;</td><td class="fielddoc"><p >MUX setting RX_0_TX_2_XCK_3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077ac937b1e1063cc3d094c4534c022af703" name="gga87bbdb9f7edb3f1866aeb498bf7c9077ac937b1e1063cc3d094c4534c022af703"></a>USART_RX_1_TX_0_XCK_1&#160;</td><td class="fielddoc"><p >MUX setting RX_1_TX_0_XCK_1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077a884ae3424a45469c20b4ecf9c65a8e48" name="gga87bbdb9f7edb3f1866aeb498bf7c9077a884ae3424a45469c20b4ecf9c65a8e48"></a>USART_RX_1_TX_2_XCK_3&#160;</td><td class="fielddoc"><p >MUX setting RX_1_TX_2_XCK_3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077a730a5c0276235851c892b3a817a6d49f" name="gga87bbdb9f7edb3f1866aeb498bf7c9077a730a5c0276235851c892b3a817a6d49f"></a>USART_RX_2_TX_0_XCK_1&#160;</td><td class="fielddoc"><p >MUX setting RX_2_TX_0_XCK_1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077aa64f03365c6e57705c9a154741523956" name="gga87bbdb9f7edb3f1866aeb498bf7c9077aa64f03365c6e57705c9a154741523956"></a>USART_RX_2_TX_2_XCK_3&#160;</td><td class="fielddoc"><p >MUX setting RX_2_TX_2_XCK_3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077a01cd27a54558c7956d41d29c16cf4a40" name="gga87bbdb9f7edb3f1866aeb498bf7c9077a01cd27a54558c7956d41d29c16cf4a40"></a>USART_RX_3_TX_0_XCK_1&#160;</td><td class="fielddoc"><p >MUX setting RX_3_TX_0_XCK_1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87bbdb9f7edb3f1866aeb498bf7c9077a026e9eb10b4f94b2a0e5640a9fe22544" name="gga87bbdb9f7edb3f1866aeb498bf7c9077a026e9eb10b4f94b2a0e5640a9fe22544"></a>USART_RX_3_TX_2_XCK_3&#160;</td><td class="fielddoc"><p >MUX setting RX_3_TX_2_XCK_3 </p>
</td></tr>
</table>

</div>
</div>
<a id="gab7d8ac715e2bd7ccddc65bf2c5ceb1f5" name="gab7d8ac715e2bd7ccddc65bf2c5ceb1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d8ac715e2bd7ccddc65bf2c5ceb1f5">&#9670;&#160;</a></span>usart_stopbits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gab7d8ac715e2bd7ccddc65bf2c5ceb1f5">usart_stopbits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Stop Bits enum. </p>
<p >Number of stop bits for a frame. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a9011413422d1340bb5c343a1f3b57341" name="ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a9011413422d1340bb5c343a1f3b57341"></a>USART_STOPBITS_1&#160;</td><td class="fielddoc"><p >Each transferred frame contains one stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a1e3cd9a88a519d93c0c300e873437a2c" name="ggab7d8ac715e2bd7ccddc65bf2c5ceb1f5a1e3cd9a88a519d93c0c300e873437a2c"></a>USART_STOPBITS_2&#160;</td><td class="fielddoc"><p >Each transferred frame contains two stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab1b986bc581f76e99eec14ac37efe05" name="gaab1b986bc581f76e99eec14ac37efe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1b986bc581f76e99eec14ac37efe05">&#9670;&#160;</a></span>usart_transceiver_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Transceiver. </p>
<p >Select Receiver or Transmitter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab1b986bc581f76e99eec14ac37efe05a627832963965f11ae53299b802582c48" name="ggaab1b986bc581f76e99eec14ac37efe05a627832963965f11ae53299b802582c48"></a>USART_TRANSCEIVER_RX&#160;</td><td class="fielddoc"><p >The parameter is for the Receiver </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab1b986bc581f76e99eec14ac37efe05a9d1050c223a28be7aefcbca46a0add81" name="ggaab1b986bc581f76e99eec14ac37efe05a9d1050c223a28be7aefcbca46a0add81"></a>USART_TRANSCEIVER_TX&#160;</td><td class="fielddoc"><p >The parameter is for the Transmitter </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7ff4d85053b8ea0904b5a57587b39c8f" name="ga7ff4d85053b8ea0904b5a57587b39c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ff4d85053b8ea0904b5a57587b39c8f">&#9670;&#160;</a></span>usart_transfer_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#ga7ff4d85053b8ea0904b5a57587b39c8f">usart_transfer_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USART Transfer mode enum. </p>
<p >Select USART transfer mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7ff4d85053b8ea0904b5a57587b39c8fa4756b64694eb2e2ca4f4c77c6f53786d" name="gga7ff4d85053b8ea0904b5a57587b39c8fa4756b64694eb2e2ca4f4c77c6f53786d"></a>USART_TRANSFER_SYNCHRONOUSLY&#160;</td><td class="fielddoc"><p >Transfer of data is done synchronously </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7ff4d85053b8ea0904b5a57587b39c8fa5662e0cc82a73f113bb13ebb1e4c65ef" name="gga7ff4d85053b8ea0904b5a57587b39c8fa5662e0cc82a73f113bb13ebb1e4c65ef"></a>USART_TRANSFER_ASYNCHRONOUSLY&#160;</td><td class="fielddoc"><p >Transfer of data is done asynchronously </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga08e77aeb7ff01d060c5c936a63581a99" name="ga08e77aeb7ff01d060c5c936a63581a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e77aeb7ff01d060c5c936a63581a99">&#9670;&#160;</a></span>usart_abort_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usart_abort_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a>&#160;</td>
          <td class="paramname"><em>transceiver_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels ongoing read/write operation. </p>
<p >Cancels the ongoing read/write operation modifying parameters in the USART software struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transceiver_type</td><td>Transfer type to cancel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80364bc53d6d6405a2a7f3b1aa507503" name="ga80364bc53d6d6405a2a7f3b1aa507503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80364bc53d6d6405a2a7f3b1aa507503">&#9670;&#160;</a></span>usart_get_job_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_get_job_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__usart__group.html#gaab1b986bc581f76e99eec14ac37efe05">usart_transceiver_type</a>&#160;</td>
          <td class="paramname"><em>transceiver_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status from the ongoing or last asynchronous transfer operation. </p>
<p >Returns the error from a given ongoing or last asynchronous transfer operation. Either from a read or write transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transceiver_type</td><td>Transfer type to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the given job. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>No error occurred during the last transfer </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>A transfer is ongoing </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_DATA</td><td>The last operation was aborted due to a parity error. The transfer could be affected by external noise </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>The last operation was aborted due to a frame error </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>The last operation was aborted due to a buffer overflow </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>An invalid transceiver enum given </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad67046f395137b2a7a1ef72f83907674" name="gad67046f395137b2a7a1ef72f83907674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67046f395137b2a7a1ef72f83907674">&#9670;&#160;</a></span>usart_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_sercom.html">Sercom</a> *const&#160;</td>
          <td class="paramname"><em>hw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structusart__config.html">usart_config</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the device. </p>
<p >Initializes the USART device based on the setting specified in the configuration struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">module</td><td>Pointer to USART device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to USART hardware instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the initialization.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The initialization was successful </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>The USART module is busy resetting </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>The USART has not been disabled in advance of initialization </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>The configuration struct contains invalid configuration </td></tr>
    <tr><td class="paramname">STATUS_ERR_ALREADY_INITIALIZED</td><td>The SERCOM instance has already been initialized with different clock configuration </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAUD_UNAVAILABLE</td><td>The BAUD rate given by the configuration struct cannot be reached with the current clock configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95b1e55af02e69454ecff04c3d712527" name="ga95b1e55af02e69454ecff04c3d712527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b1e55af02e69454ecff04c3d712527">&#9670;&#160;</a></span>usart_read_buffer_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_read_buffer_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous buffer read. </p>
<p >Sets up the driver to read from the USART to a given buffer. If registered and enabled, a callback function will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to data buffer to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Data buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 9-bit data, the array that <em>rx_data point to should be defined as uint16_t array and should be casted to uint8_t</em> pointer. Because it is an address pointer, the highest byte is not discarded. For example: <div class="fragment"><div class="line"><span class="preprocessor">#define RX_LEN 3</span></div>
<div class="line">uint16_t rx_buf[RX_LEN] = {0x0,};</div>
<div class="line"><a class="code hl_function" href="group__asfdoc__sam0__sercom__usart__group.html#ga95b1e55af02e69454ecff04c3d712527">usart_read_buffer_job</a>(&amp;module, (uint8_t*)rx_buf, RX_LEN);</div>
<div class="ttc" id="agroup__asfdoc__sam0__sercom__usart__group_html_ga95b1e55af02e69454ecff04c3d712527"><div class="ttname"><a href="group__asfdoc__sam0__sercom__usart__group.html#ga95b1e55af02e69454ecff04c3d712527">usart_read_buffer_job</a></div><div class="ttdeci">enum status_code usart_read_buffer_job(struct usart_module *const module, uint8_t *rx_data, uint16_t length)</div><div class="ttdoc">Asynchronous buffer read.</div><div class="ttdef"><b>Definition:</b> usart_interrupt.c:330</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If operation was not completed, due to the USART module being busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If operation was not completed, due to invalid arguments </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the transmitter is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f788b3478e9c1fa8f0dd8d09939d3a6" name="ga4f788b3478e9c1fa8f0dd8d09939d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f788b3478e9c1fa8f0dd8d09939d3a6">&#9670;&#160;</a></span>usart_read_buffer_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_read_buffer_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a buffer of <code>length</code> characters via the USART. </p>
<p >This blocking function will receive a block of <code>length</code> characters via the USART.</p>
<dl class="section note"><dt>Note</dt><dd>Using this function in combination with the interrupt (<code>*_job</code>) functions is not recommended as it has no functionality to check if there is an ongoing interrupt driven operation running or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to receive buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of characters to receive</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 9-bit data, the array that <em>rx_data point to should be defined as uint16_t array and should be casted to uint8_t</em> pointer. Because it is an address pointer, the highest byte is not discarded. For example: <div class="fragment"><div class="line"><span class="preprocessor">#define RX_LEN 3</span></div>
<div class="line">uint16_t rx_buf[RX_LEN] = {0x0,};</div>
<div class="line"><a class="code hl_function" href="group__asfdoc__sam0__sercom__usart__group.html#ga4f788b3478e9c1fa8f0dd8d09939d3a6">usart_read_buffer_wait</a>(&amp;module, (uint8_t*)rx_buf, RX_LEN);</div>
<div class="ttc" id="agroup__asfdoc__sam0__sercom__usart__group_html_ga4f788b3478e9c1fa8f0dd8d09939d3a6"><div class="ttname"><a href="group__asfdoc__sam0__sercom__usart__group.html#ga4f788b3478e9c1fa8f0dd8d09939d3a6">usart_read_buffer_wait</a></div><div class="ttdeci">enum status_code usart_read_buffer_wait(struct usart_module *const module, uint8_t *rx_data, uint16_t length)</div><div class="ttdoc">Receive a buffer of length characters via the USART.</div><div class="ttdef"><b>Definition:</b> usart.c:750</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If operation was not completed, due to an invalid argument being supplied </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If operation was not completed, due to USART module timing out </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>If the operation was not completed, due to a configuration mismatch between USART and the sender </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_OVERFLOW</td><td>If the operation was not completed, due to the baudrate being too low or the system frequency being too high </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_DATA</td><td>If the operation was not completed, due to data being corrupted </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga095085e94cc009c31243df62395896fd" name="ga095085e94cc009c31243df62395896fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095085e94cc009c31243df62395896fd">&#9670;&#160;</a></span>usart_read_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_read_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>rx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous read a single char. </p>
<p >Sets up the driver to read data from the USART module to the data pointer given. If registered and enabled, a callback will be called when the receiving is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to where received data should be put</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If operation was not completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7db90c51a6f17edff5f1de2a0e3d8a5" name="gaf7db90c51a6f17edff5f1de2a0e3d8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7db90c51a6f17edff5f1de2a0e3d8a5">&#9670;&#160;</a></span>usart_read_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_read_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>rx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a character via the USART. </p>
<p >This blocking function will receive a character via the USART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to received data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation was completed </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If the operation was not completed, due to the USART module being busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>If the operation was not completed, due to configuration mismatch between USART and the sender </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_OVERFLOW</td><td>If the operation was not completed, due to the baudrate being too low or the system frequency being too high </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_DATA</td><td>If the operation was not completed, due to data being corrupted </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39e38593fb41abe34cec95d53c7b1e37" name="ga39e38593fb41abe34cec95d53c7b1e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e38593fb41abe34cec95d53c7b1e37">&#9670;&#160;</a></span>usart_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usart_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usart_callback_t&#160;</td>
          <td class="paramname"><em>callback_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum usart_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback. </p>
<p >Registers a callback function, which is implemented by the user.</p>
<dl class="section note"><dt>Note</dt><dd>The callback must be enabled by usart_enable_callback in order for the interrupt handler to call it when the conditions for the callback type are met.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_func</td><td>Pointer to callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type given by an enum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5be8cd239bf4acd63e341be97a5cd602" name="ga5be8cd239bf4acd63e341be97a5cd602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be8cd239bf4acd63e341be97a5cd602">&#9670;&#160;</a></span>usart_unregister_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usart_unregister_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum usart_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a callback. </p>
<p >Unregisters a callback function, which is implemented by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type given by an enum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2811c1f5cd7fdcf653eac02812f2265c" name="ga2811c1f5cd7fdcf653eac02812f2265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2811c1f5cd7fdcf653eac02812f2265c">&#9670;&#160;</a></span>usart_write_buffer_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_write_buffer_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous buffer write. </p>
<p >Sets up the driver to write a given buffer over the USART. If registered and enabled, a callback function will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Pointer do data buffer to transmit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 9-bit data, the array that <em>tx_data point to should be defined as uint16_t array and should be casted to uint8_t</em> pointer. Because it is an address pointer, the highest byte is not discarded. For example: <div class="fragment"><div class="line"><span class="preprocessor">#define TX_LEN 3</span></div>
<div class="line">uint16_t tx_buf[TX_LEN] = {0x0111, 0x0022, 0x0133};</div>
<div class="line"><a class="code hl_function" href="group__asfdoc__sam0__sercom__usart__group.html#ga2811c1f5cd7fdcf653eac02812f2265c">usart_write_buffer_job</a>(&amp;module, (uint8_t*)tx_buf, TX_LEN);</div>
<div class="ttc" id="agroup__asfdoc__sam0__sercom__usart__group_html_ga2811c1f5cd7fdcf653eac02812f2265c"><div class="ttname"><a href="group__asfdoc__sam0__sercom__usart__group.html#ga2811c1f5cd7fdcf653eac02812f2265c">usart_write_buffer_job</a></div><div class="ttdeci">enum status_code usart_write_buffer_job(struct usart_module *const module, uint8_t *tx_data, uint16_t length)</div><div class="ttdoc">Asynchronous buffer write.</div><div class="ttdef"><b>Definition:</b> usart_interrupt.c:281</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed successfully. </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If operation was not completed, due to the USART module being busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If operation was not completed, due to invalid arguments </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the transmitter is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacffd0845249348d37d14c65a41132e41" name="gacffd0845249348d37d14c65a41132e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacffd0845249348d37d14c65a41132e41">&#9670;&#160;</a></span>usart_write_buffer_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_write_buffer_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a buffer of characters via the USART. </p>
<p >This blocking function will transmit a block of <code>length</code> characters via the USART.</p>
<dl class="section note"><dt>Note</dt><dd>Using this function in combination with the interrupt (<code>_job</code>) functions is not recommended as it has no functionality to check if there is an ongoing interrupt driven operation running or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Pointer to data to transmit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of characters to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 9-bit data, the array that <em>tx_data point to should be defined as uint16_t array and should be casted to uint8_t</em> pointer. Because it is an address pointer, the highest byte is not discarded. For example: <div class="fragment"><div class="line"><span class="preprocessor">#define TX_LEN 3</span></div>
<div class="line">uint16_t tx_buf[TX_LEN] = {0x0111, 0x0022, 0x0133};</div>
<div class="line"><a class="code hl_function" href="group__asfdoc__sam0__sercom__usart__group.html#gacffd0845249348d37d14c65a41132e41">usart_write_buffer_wait</a>(&amp;module, (uint8_t*)tx_buf, TX_LEN);</div>
<div class="ttc" id="agroup__asfdoc__sam0__sercom__usart__group_html_gacffd0845249348d37d14c65a41132e41"><div class="ttname"><a href="group__asfdoc__sam0__sercom__usart__group.html#gacffd0845249348d37d14c65a41132e41">usart_write_buffer_wait</a></div><div class="ttdeci">enum status_code usart_write_buffer_wait(struct usart_module *const module, const uint8_t *tx_data, uint16_t length)</div><div class="ttdoc">Transmit a buffer of characters via the USART.</div><div class="ttdef"><b>Definition:</b> usart.c:651</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If operation was not completed, due to invalid arguments </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If operation was not completed, due to USART module timing out </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the transmitter is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e68847c609aa708be3e1f282f760e8d" name="ga3e68847c609aa708be3e1f282f760e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e68847c609aa708be3e1f282f760e8d">&#9670;&#160;</a></span>usart_write_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_write_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous write a single char. </p>
<p >Sets up the driver to write the data given. If registered and enabled, a callback function will be called when the transmit is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Data to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If operation was completed </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If operation was not completed, due to the USART module being busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the transmitter is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee8b142e8ad13e1e226334a9954e853c" name="gaee8b142e8ad13e1e226334a9954e853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8b142e8ad13e1e226334a9954e853c">&#9670;&#160;</a></span>usart_write_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> usart_write_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structusart__module.html">usart_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>tx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a character via the USART. </p>
<p >This blocking function will transmit a single character via the USART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Data to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation was completed </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If the operation was not completed, due to the USART module being busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the transmitter is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
